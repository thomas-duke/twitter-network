def hide_edges(G: Graph, targets: dict, parameters: dict) -> Graph:
    """Remove a random subset of edges from an undirected graph.

        Args:
            targets: training adjacency list as a dictionary, with source nodes as keys
            and target nodes as values.

            parameters: parameters defined in parameters.yml.

        Returns:
            A dictionary containing:
                subG: the subgraph of G generated by hiding edges.
                hidden: list of hidden edges.

    """
    # Generate a random list of edges to hide
    hidden = []
    np.random.seed(parameters["seed"])
    sources = list(targets.keys())
    N_hidden = parameters["setup"]["N_hidden"]
    sources_hidden = np.random.choice(sources, size=N_hidden)
    while len(hidden) < N_hidden:
        s = sources_hidden.pop()
        subtargets = targets[s]
        if len(subtargets) == 0:
            sources_hidden.append(np.random.choice(sources))
            continue
        t = np.random.choice(subtargets)
        if (s, t) not in hidden:
            hidden.append((s, t))

    # Create a subgraph by removing edges
    subG = deepcopy(G)
    subG.remove_edges_from(hidden)

    return dict(subG=subG, hidden=hidden)


def fake_edges(
    targets: dict, subG: Graph, hidden: list, test: list, parameters: dict
) -> list:
    """Randomly generates fake edges from source nodes to target nodes in a subgraph.

        Args:
            targets: training adjacency list as a dictionary, with source nodes as keys
            and target nodes as values.

            subG: a NetworkX graph object, which is a subgraph of the training network.

            hidden: list of hidden edges.

            test: list of edges in the test set.

            parameters: parameters defined in parameters.yml.

        Returns:
            List of source nodes.

    """
    fakes = []
    sources = list(targets.keys())
    subtargets = subG.nodes
    np.random.seed(parameters["seed"])
    while len(fakes) < parameters["setup"]["N_fake"]:
        s = np.random.choice(sources)
        t = np.random.choice(subtargets)
        if (
            s != t  # no self loops
            and not subG.has_edge(s, t)  # edge does not exist in subgraph
            and not (s, t) in hidden  # edge has not been hidden
            and not (s, t) in test  # edge is not in the test set
            and not (s, t) in fakes  # edge has not already been created
        ):
            fakes.append((s, t))
    return fakes


def create_sample(hidden: list, fakes: list) -> pd.DataFrame:
    """Creates a Pandas DataFrame with a random ordering of hidden edges and fake edges.

    Args:
        hidden: list of hidden edges.

        fakes:  list of fake edges.

    Returns:
        Pandas dataframe with two columns:
            edge: the edge as a tuple in the form (source, sink).
            label: a binary variable taking the value 1 if the edge was hidden and 0
            if it was fake.

    """
    sample = [(x, 1) for x in hidden] + [(x, 0) for x in fakes]
    np.random.shuffle(sample)
    return pd.DataFrame(sample, columns=["edge", "label"])
